---
description: ExpenseFlow Project-Specific Rules and Guidelines
globs: ["**/*.{ts,tsx,js,jsx}"]
alwaysApply: true
---

# ExpenseFlow Project Rules

## Project Context

ExpenseFlow is an Enterprise Expense Approval System frontend built with:
- **Framework:** Next.js 15 (App Router)
- **Language:** TypeScript
- **Styling:** Tailwind CSS + shadcn/ui
- **Icons:** Hugeicons (`@hugeicons/react`) or `lucide-react`
- **Backend:** ASP.NET Web API (External)
- **State Management:** React Query + Context API

## Global Development Rules

### Type Safety
- **NEVER** use generic placeholders like `any`, `unknown` without proper type guards
- Use strict TypeScript types for all props, state, and API responses
- Define proper interfaces/types for all data structures
- Use type inference only when types are obvious and unambiguous

```typescript
// ✅ Good: Strict typing
interface ExpenseSubmission {
  id: string;
  amount: number;
  category: ExpenseCategory;
  description: string;
  submittedAt: Date;
  status: ExpenseStatus;
}

const ExpenseCard: React.FC<{ expense: ExpenseSubmission }> = ({ expense }) => {
  // Component implementation
};

// ❌ Bad: Generic placeholders
const ExpenseCard = ({ expense }: { expense: any }) => {
  // Component implementation
};
```

### Icon Usage
- **Primary:** Use `@hugeicons/react` for icons
- **Fallback:** Use `lucide-react` if Hugeicons doesn't have the needed icon
- Always import icons explicitly, never use wildcard imports

```typescript
// ✅ Good: Explicit imports
import { Home01Icon, Settings01Icon } from "@hugeicons/react";
import { User, Settings } from "lucide-react";

// ❌ Bad: Wildcard imports
import * as Icons from "@hugeicons/react";
```

### Component Architecture
- Keep components **small and atomic**
- Each component should have a single, well-defined responsibility
- Prefer composition over complex monolithic components
- Extract reusable logic into custom hooks

```typescript
// ✅ Good: Atomic components
const ExpenseAmount: React.FC<{ amount: number; currency: string }> = ({ amount, currency }) => {
  return <span>{formatCurrency(amount, currency)}</span>;
};

const ExpenseStatusBadge: React.FC<{ status: ExpenseStatus }> = ({ status }) => {
  return <Badge variant={getStatusVariant(status)}>{status}</Badge>;
};

// ❌ Bad: Monolithic component doing everything
const ExpenseCard = ({ expense }) => {
  // Formats amount, shows status, handles clicks, fetches data, etc.
};
```

### Feature Development Workflow

When implementing a new feature, follow this strict order:

1. **UI Shell First** - Build the visual structure and layout
   - Create component structure
   - Add styling with Tailwind CSS
   - Use shadcn/ui components
   - Add placeholder/mock data for visual development
   - Ensure responsive design

2. **Logic Second** - Add functionality after UI is complete
   - Integrate React Query for data fetching
   - Add Context API for global state if needed
   - Implement event handlers
   - Add form validation
   - Connect to backend API

```typescript
// Step 1: UI Shell (no logic)
const ExpenseForm: React.FC = () => {
  return (
    <Card>
      <CardHeader>
        <CardTitle>Submit Expense</CardTitle>
      </CardHeader>
      <CardContent>
        <form>
          <Input placeholder="Amount" />
          <Select placeholder="Category" />
          <Textarea placeholder="Description" />
          <Button>Submit</Button>
        </form>
      </CardContent>
    </Card>
  );
};

// Step 2: Add Logic (after UI is complete)
const ExpenseForm: React.FC = () => {
  const { mutate: submitExpense } = useMutation({
    mutationFn: createExpense,
    onSuccess: () => {
      toast.success("Expense submitted successfully");
    },
  });

  const handleSubmit = (data: ExpenseFormData) => {
    submitExpense(data);
  };

  return (
    <Card>
      {/* Same UI structure */}
      <Form onSubmit={handleSubmit}>
        {/* Form fields with validation */}
      </Form>
    </Card>
  );
};
```

## Next.js 15 App Router Patterns

### Server Components by Default
- Use Server Components unless interactivity is required
- Mark client components with `"use client"` directive
- Keep client components minimal and focused

```typescript
// ✅ Good: Server Component (default)
const ExpenseList: React.FC<{ expenses: Expense[] }> = ({ expenses }) => {
  return (
    <div>
      {expenses.map((expense) => (
        <ExpenseCard key={expense.id} expense={expense} />
      ))}
    </div>
  );
};

// ✅ Good: Client Component (when needed)
"use client";

const ExpenseForm: React.FC = () => {
  const [amount, setAmount] = useState(0);
  // Interactive logic
};
```

### API Integration
- Use React Query (`@tanstack/react-query`) for all API calls
- Create typed API client functions
- Handle loading and error states properly
- Use proper TypeScript types for API responses

```typescript
// ✅ Good: Typed API integration
interface ApiResponse<T> {
  data: T;
  success: boolean;
  message?: string;
}

const fetchExpenses = async (): Promise<ApiResponse<Expense[]>> => {
  const response = await fetch("/api/expenses");
  if (!response.ok) {
    throw new Error("Failed to fetch expenses");
  }
  return response.json();
};

const useExpenses = () => {
  return useQuery({
    queryKey: ["expenses"],
    queryFn: fetchExpenses,
  });
};
```

## State Management Guidelines

### React Query for Server State
- Use React Query for all server-side data
- Cache and synchronize data automatically
- Handle loading, error, and success states

### Context API for Client State
- Use Context API only for truly global client state
- Keep contexts focused and small
- Prefer React Query over Context for server data

```typescript
// ✅ Good: Context for UI state
const ThemeContext = createContext<{
  theme: "light" | "dark";
  toggleTheme: () => void;
}>();

// ✅ Good: React Query for server data
const { data: expenses, isLoading } = useExpenses();
```

## Styling Guidelines

### Tailwind CSS
- Use Tailwind utility classes exclusively
- Follow mobile-first responsive design
- Use design system tokens (colors, spacing, typography)
- Avoid custom CSS unless absolutely necessary

### shadcn/ui Components
- Use shadcn/ui components from `@/components/ui`
- Customize via props and className, not by modifying component files
- Follow shadcn/ui patterns for composition

```typescript
// ✅ Good: Using shadcn/ui components
import { Button } from "@/components/ui/button";
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";

<Card>
  <CardHeader>
    <CardTitle>Expense Details</CardTitle>
  </CardHeader>
  <CardContent>
    <Button variant="outline">Edit</Button>
  </CardContent>
</Card>
```

## Code Organization

### File Structure
```
frontend/
├── app/                    # Next.js App Router pages
├── components/
│   ├── ui/                 # shadcn/ui components
│   └── features/           # Feature-specific components
├── lib/
│   ├── api/                # API client functions
│   ├── hooks/              # Custom React hooks
│   └── utils/              # Utility functions
├── types/                  # TypeScript type definitions
└── contexts/               # React Context providers
```

### Import Organization
```typescript
// 1. React and Next.js
import { useState, useEffect } from "react";
import { useRouter } from "next/navigation";

// 2. External libraries
import { useQuery } from "@tanstack/react-query";
import { Home01Icon } from "@hugeicons/react";

// 3. Internal components
import { Button } from "@/components/ui/button";
import { ExpenseCard } from "@/components/features/expenses";

// 4. Internal utilities and types
import { formatCurrency } from "@/lib/utils";
import type { Expense } from "@/types/expense";

// 5. Relative imports
import "./styles.css";
```

## Error Handling

### API Errors
- Always handle API errors gracefully
- Show user-friendly error messages
- Use toast notifications for feedback
- Log errors for debugging

```typescript
const useExpenses = () => {
  return useQuery({
    queryKey: ["expenses"],
    queryFn: fetchExpenses,
    onError: (error: Error) => {
      toast.error(`Failed to load expenses: ${error.message}`);
    },
  });
};
```

### Form Validation
- Use proper form validation libraries (e.g., react-hook-form + zod)
- Show validation errors inline
- Prevent submission of invalid data

## Performance Considerations

### Code Splitting
- Use dynamic imports for heavy components
- Lazy load routes when appropriate
- Optimize images with Next.js Image component

### React Optimization
- Use `React.memo` for expensive components
- Use `useMemo` and `useCallback` appropriately
- Avoid unnecessary re-renders

## Testing Approach

- Write tests for business logic
- Test component behavior, not implementation
- Use proper TypeScript types in tests
- Mock API calls appropriately

## Accessibility

- Follow WCAG 2.1 AA standards
- Use semantic HTML elements
- Provide proper ARIA labels
- Ensure keyboard navigation works
- Test with screen readers

## Summary Checklist

When implementing a feature:
- [ ] UI shell is complete and styled
- [ ] All components are properly typed
- [ ] Icons are from Hugeicons or Lucide
- [ ] Components are small and atomic
- [ ] React Query is used for server state
- [ ] Error handling is implemented
- [ ] Loading states are handled
- [ ] Responsive design is verified
- [ ] Accessibility requirements are met
- [ ] TypeScript types are strict (no `any`)
