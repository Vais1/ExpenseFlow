---
description: ExpenseFlow Backend Project-Specific Rules and Guidelines
globs: ["**/*.cs"]
alwaysApply: true
---

# ExpenseFlow Backend Rules

## Project Context

ExpenseFlow backend is an Enterprise Expense Approval System API built with:
- **Framework:** ASP.NET Core Web API (.NET 9)
- **Language:** C#
- **Database:** MongoDB (using MongoDB.Driver)
- **Authentication:** JWT Bearer Token
- **Architecture:** Clean Architecture (Controller-Service-Repository pattern)

## Global Development Rules

### DTOs (Data Transfer Objects)
- **ALWAYS** use DTOs for all API requests and responses
- **NEVER** return database entities directly from controllers
- Separate DTOs for requests and responses when needed
- Use `record` types for DTOs when appropriate (immutable, value-based equality)

```csharp
// ✅ Good: Using DTOs
public record CreateExpenseRequest(
    decimal Amount,
    string Category,
    string Description,
    DateTime Date
);

public record ExpenseResponse(
    string Id,
    decimal Amount,
    string Category,
    string Description,
    DateTime Date,
    string Status
);

// ❌ Bad: Returning entities directly
[HttpGet]
public async Task<ExpenseEntity> GetExpense(string id) { }
```

### Async/Await Patterns
- Use `async/await` for **ALL** I/O operations (database, HTTP calls, file operations)
- Return `Task<T>` or `Task` from async methods
- Use `ConfigureAwait(false)` in library code (optional in ASP.NET Core controllers)
- Never use `.Result` or `.Wait()` on async methods

```csharp
// ✅ Good: Proper async/await
public async Task<ExpenseResponse> GetExpenseAsync(string id)
{
    var entity = await _repository.GetByIdAsync(id);
    return MapToResponse(entity);
}

// ❌ Bad: Blocking async calls
public ExpenseResponse GetExpense(string id)
{
    var entity = _repository.GetByIdAsync(id).Result; // NEVER DO THIS
    return MapToResponse(entity);
}
```

### Type Safety and Nullable Reference Types
- Enable nullable reference types (`<Nullable>enable</Nullable>`)
- Use nullable annotations (`string?`, `int?`) appropriately
- Validate null inputs in controllers/services
- Use null-forgiving operator (`!`) sparingly and only when certain

```csharp
// ✅ Good: Nullable reference types
public async Task<ExpenseResponse?> GetExpenseAsync(string? id)
{
    if (string.IsNullOrWhiteSpace(id))
        return null;
    
    var entity = await _repository.GetByIdAsync(id);
    return entity is null ? null : MapToResponse(entity);
}

// ❌ Bad: Ignoring nullability
public async Task<ExpenseResponse> GetExpenseAsync(string id)
{
    var entity = await _repository.GetByIdAsync(id);
    return MapToResponse(entity); // What if entity is null?
}
```

### HTTP Status Codes
- Use standard HTTP status codes consistently:
  - `200 OK` - Successful GET, PUT, PATCH
  - `201 Created` - Successful POST (resource created)
  - `204 No Content` - Successful DELETE
  - `400 Bad Request` - Invalid request data
  - `401 Unauthorized` - Missing or invalid authentication
  - `403 Forbidden` - Authenticated but not authorized
  - `404 Not Found` - Resource not found
  - `500 Internal Server Error` - Server errors

```csharp
// ✅ Good: Proper status codes
[HttpPost]
public async Task<ActionResult<ExpenseResponse>> CreateExpense(
    CreateExpenseRequest request)
{
    var expense = await _service.CreateExpenseAsync(request);
    return CreatedAtAction(
        nameof(GetExpense),
        new { id = expense.Id },
        expense);
}

[HttpGet("{id}")]
public async Task<ActionResult<ExpenseResponse>> GetExpense(string id)
{
    var expense = await _service.GetExpenseAsync(id);
    return expense is null ? NotFound() : Ok(expense);
}
```

### MongoDB Integration

#### Entity Attributes
- Use `[BsonId]` for the primary key field
- Use `[BsonRepresentation(BsonType.ObjectId)]` for string IDs that map to ObjectId
- Use `[BsonElement("fieldName")]` for custom field names
- Use `[BsonIgnore]` for properties that shouldn't be stored

```csharp
// ✅ Good: MongoDB entity
using MongoDB.Bson;
using MongoDB.Bson.Serialization.Attributes;

public class ExpenseEntity
{
    [BsonId]
    [BsonRepresentation(BsonType.ObjectId)]
    public string Id { get; set; } = string.Empty;
    
    [BsonElement("amount")]
    public decimal Amount { get; set; }
    
    [BsonElement("category")]
    public string Category { get; set; } = string.Empty;
    
    [BsonElement("description")]
    public string Description { get; set; } = string.Empty;
    
    [BsonElement("date")]
    public DateTime Date { get; set; }
    
    [BsonElement("status")]
    public string Status { get; set; } = "Pending";
    
    [BsonElement("userId")]
    [BsonRepresentation(BsonType.ObjectId)]
    public string UserId { get; set; } = string.Empty;
    
    [BsonElement("createdAt")]
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
}
```

#### Repository Pattern
- Create repositories for each aggregate root
- Use `IMongoCollection<T>` for database operations
- Implement async methods for all operations
- Handle MongoDB exceptions appropriately

```csharp
// ✅ Good: Repository pattern
public interface IExpenseRepository
{
    Task<ExpenseEntity?> GetByIdAsync(string id);
    Task<IEnumerable<ExpenseEntity>> GetByUserIdAsync(string userId);
    Task<ExpenseEntity> CreateAsync(ExpenseEntity entity);
    Task<ExpenseEntity> UpdateAsync(ExpenseEntity entity);
    Task<bool> DeleteAsync(string id);
}

public class ExpenseRepository : IExpenseRepository
{
    private readonly IMongoCollection<ExpenseEntity> _collection;
    
    public ExpenseRepository(IMongoDatabase database)
    {
        _collection = database.GetCollection<ExpenseEntity>("expenses");
    }
    
    public async Task<ExpenseEntity?> GetByIdAsync(string id)
    {
        return await _collection
            .Find(x => x.Id == id)
            .FirstOrDefaultAsync();
    }
    
    public async Task<ExpenseEntity> CreateAsync(ExpenseEntity entity)
    {
        await _collection.InsertOneAsync(entity);
        return entity;
    }
}
```

## Clean Architecture Layers

### Controllers (API Layer)
- Handle HTTP requests/responses only
- Validate input using DTOs
- Call services, not repositories directly
- Return appropriate HTTP status codes
- Use `[Authorize]` attribute for protected endpoints

```csharp
[ApiController]
[Route("api/[controller]")]
[Authorize]
public class ExpensesController : ControllerBase
{
    private readonly IExpenseService _expenseService;
    
    public ExpensesController(IExpenseService expenseService)
    {
        _expenseService = expenseService;
    }
    
    [HttpPost]
    public async Task<ActionResult<ExpenseResponse>> CreateExpense(
        CreateExpenseRequest request)
    {
        var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
        if (string.IsNullOrEmpty(userId))
            return Unauthorized();
        
        var expense = await _expenseService.CreateExpenseAsync(request, userId);
        return CreatedAtAction(nameof(GetExpense), new { id = expense.Id }, expense);
    }
}
```

### Services (Business Logic Layer)
- Contain business logic and validation
- Coordinate between repositories
- Handle domain rules and workflows
- Map between entities and DTOs
- Throw domain exceptions for business rule violations

```csharp
public interface IExpenseService
{
    Task<ExpenseResponse> CreateExpenseAsync(
        CreateExpenseRequest request,
        string userId);
    Task<ExpenseResponse?> GetExpenseAsync(string id, string userId);
    Task<IEnumerable<ExpenseResponse>> GetUserExpensesAsync(string userId);
}

public class ExpenseService : IExpenseService
{
    private readonly IExpenseRepository _repository;
    
    public ExpenseService(IExpenseRepository repository)
    {
        _repository = repository;
    }
    
    public async Task<ExpenseResponse> CreateExpenseAsync(
        CreateExpenseRequest request,
        string userId)
    {
        // Business logic validation
        if (request.Amount <= 0)
            throw new ArgumentException("Amount must be greater than zero");
        
        var entity = new ExpenseEntity
        {
            Amount = request.Amount,
            Category = request.Category,
            Description = request.Description,
            Date = request.Date,
            Status = "Pending",
            UserId = userId,
            CreatedAt = DateTime.UtcNow
        };
        
        var created = await _repository.CreateAsync(entity);
        return MapToResponse(created);
    }
    
    private static ExpenseResponse MapToResponse(ExpenseEntity entity)
    {
        return new ExpenseResponse(
            entity.Id,
            entity.Amount,
            entity.Category,
            entity.Description,
            entity.Date,
            entity.Status
        );
    }
}
```

### Repositories (Data Access Layer)
- Handle all database operations
- Abstract MongoDB-specific code
- Return entities, not DTOs
- Use async methods exclusively

## Dependency Injection

- Register all services in `Program.cs`
- Use interfaces for all services and repositories
- Use scoped lifetime for services and repositories
- Use singleton for MongoDB client

```csharp
// ✅ Good: Dependency injection setup
var builder = WebApplication.CreateBuilder(args);

// MongoDB
var connectionString = builder.Configuration.GetConnectionString("MongoDB");
var client = new MongoClient(connectionString);
var database = client.GetDatabase("expenseflow");
builder.Services.AddSingleton<IMongoDatabase>(database);

// Repositories
builder.Services.AddScoped<IExpenseRepository, ExpenseRepository>();
builder.Services.AddScoped<IUserRepository, UserRepository>();

// Services
builder.Services.AddScoped<IExpenseService, ExpenseService>();
builder.Services.AddScoped<IUserService, UserService>();

// Controllers
builder.Services.AddControllers();
```

## JWT Authentication

- Use `Microsoft.AspNetCore.Authentication.JwtBearer`
- Configure JWT in `Program.cs`
- Use `[Authorize]` attribute on protected endpoints
- Extract user claims from `HttpContext.User`
- Validate roles using `[Authorize(Roles = "Manager")]`

```csharp
// ✅ Good: JWT configuration
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            ValidIssuer = builder.Configuration["Jwt:Issuer"],
            ValidAudience = builder.Configuration["Jwt:Audience"],
            IssuerSigningKey = new SymmetricSecurityKey(
                Encoding.UTF8.GetBytes(builder.Configuration["Jwt:Key"]!))
        };
    });

builder.Services.AddAuthorization();

// In controller
[Authorize(Roles = "Manager,Admin")]
[HttpPut("{id}/approve")]
public async Task<ActionResult> ApproveExpense(string id)
{
    // Implementation
}
```

## Error Handling

- Use try-catch blocks in controllers for exception handling
- Return appropriate HTTP status codes
- Log errors using `ILogger<T>`
- Create custom exceptions for domain errors

```csharp
[HttpPost]
public async Task<ActionResult<ExpenseResponse>> CreateExpense(
    CreateExpenseRequest request)
{
    try
    {
        var expense = await _expenseService.CreateExpenseAsync(request, userId);
        return CreatedAtAction(nameof(GetExpense), new { id = expense.Id }, expense);
    }
    catch (ArgumentException ex)
    {
        _logger.LogWarning(ex, "Invalid request data");
        return BadRequest(new { error = ex.Message });
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Error creating expense");
        return StatusCode(500, new { error = "An error occurred" });
    }
}
```

## Code Organization

### Project Structure
```
backend/
├── Controllers/          # API endpoints
├── Services/             # Business logic
├── Repositories/         # Data access
├── Models/              # Entities and DTOs
│   ├── Entities/        # MongoDB entities
│   └── DTOs/           # Request/Response DTOs
├── Configuration/       # Configuration classes
└── Program.cs           # Startup configuration
```

### Naming Conventions
- Controllers: `{Entity}Controller` (e.g., `ExpensesController`)
- Services: `{Entity}Service` (e.g., `ExpenseService`)
- Repositories: `{Entity}Repository` (e.g., `ExpenseRepository`)
- DTOs: `{Action}{Entity}{Type}` (e.g., `CreateExpenseRequest`, `ExpenseResponse`)
- Entities: `{Entity}Entity` (e.g., `ExpenseEntity`)

## Summary Checklist

When implementing a feature:
- [ ] DTOs are used for all requests/responses
- [ ] All I/O operations are async/await
- [ ] Nullable reference types are handled properly
- [ ] Appropriate HTTP status codes are returned
- [ ] MongoDB entities use proper BSON attributes
- [ ] Clean Architecture layers are respected
- [ ] Dependency injection is configured
- [ ] JWT authentication is applied where needed
- [ ] Error handling is implemented
- [ ] Code follows naming conventions
